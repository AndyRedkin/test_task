webpackJsonp([0],[
/* 0 */,
/* 1 */,
/* 2 */,
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(4);
module.exports = __webpack_require__(9);


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _vue = __webpack_require__(1);

var _vue2 = _interopRequireDefault(_vue);

var _vueResource = __webpack_require__(7);

var _vueResource2 = _interopRequireDefault(_vueResource);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue2.default.use(_vueResource2.default);

// Это хардкорно забитая инфа представим что она пришла по урлу /list
var data = [{ "id": "17d5653e-ab63-44cb-b1f6-403d9d7c48a0", "name": "Twitterlist", "location": "Namur", "currency": 62675 }, { "id": "9eee0e4e-d3a7-4a4c-aca8-00077164abf2", "name": "Mydo", "location": "Bojong", "currency": 18917 }, { "id": "6d3a7fd5-da98-4fc8-9818-c59ac9b15d36", "name": "Gigazoom", "location": "Marshintsy", "currency": 89681 }, { "id": "0146f5e8-226b-468b-82b2-66669dec26b2", "name": "BlogXS", "location": "Snegiri", "currency": 37538 }, { "id": "f9f903e5-4877-4147-bca2-988b1a838dcd", "name": "Edgeify", "location": "Pingyang", "currency": 25537 }, { "id": "d31a647e-5aca-4442-9ffc-638cccce00d2", "name": "Innotype", "location": "Shentong", "currency": 4115 }, { "id": "28256d73-8c9c-4005-bdda-186dbf3b0ea4", "name": "Yacero", "location": "Couva", "currency": 26663 }, { "id": "59ec4111-ab34-470b-96c7-38e2dee7d50a", "name": "Buzzster", "location": "Daveluyville", "currency": 75205 }, { "id": "0a24c7ba-1902-42e5-9eea-3274c653d241", "name": "Fivespan", "location": "Mechrá Belqsiri", "currency": 9107 }, { "id": "bb205027-6333-45b0-a830-921af731f6dc", "name": "Twinder", "location": "Baguio", "currency": 49489 }, { "id": "c362b8fb-6d80-4cd1-97b3-9c3e462362e9", "name": "Eazzy", "location": "Pangkalanbunut", "currency": 51006 }, { "id": "a4b18fe1-dc8a-421e-8dc5-4d5ef566a81a", "name": "Gabtype", "location": "Duping", "currency": 50988 }, { "id": "d7ab4cd2-7e59-42d1-abfc-8bf951b2bf4c", "name": "Browsebug", "location": "Abaetetuba", "currency": 97704 }, { "id": "e5d969c3-2e48-45dd-897e-4009800e7374", "name": "Browsedrive", "location": "Yujia", "currency": 84845 }, { "id": "97c3e326-0ae6-45f8-9229-f6fe106c84c7", "name": "Meedoo", "location": "Catujal", "currency": 20148 }, { "id": "5eca3bbc-32d4-454d-8520-ac2a561fec95", "name": "Tagtune", "location": "Delmas", "currency": 92074 }, { "id": "c6ada8ae-4824-4678-a35d-e527e2e715ba", "name": "Vidoo", "location": "Skien", "currency": 62896 }, { "id": "ea5aab43-2f7b-4cdc-84d2-126c754dca7f", "name": "Gevee", "location": "Chimen", "currency": 87636 }, { "id": "a52c1405-6eda-4749-b603-12d576ecc1e4", "name": "JumpXS", "location": "Lianglin", "currency": 11117 }, { "id": "ff2627b4-3c04-417a-a57d-d670ae1a7371", "name": "Dynabox", "location": "Thap Than", "currency": 89053 }, { "id": "8603e18a-9ba6-42a9-aa43-c87c96b790ee", "name": "Flashdog", "location": "Ciudad Choluteca", "currency": 31751 }, { "id": "b223e78a-d883-417a-b545-f0d39dbaf866", "name": "Livetube", "location": "Permas", "currency": 56178 }, { "id": "ca7bf221-63ee-4180-8ee7-0819ad3a2346", "name": "Oyope", "location": "Río Colorado", "currency": 83975 }, { "id": "af6c271b-f256-4309-b3ae-ae6c21db1437", "name": "Fivebridge", "location": "Älvdalen", "currency": 72046 }, { "id": "edad6171-7652-4b41-ae9f-b3c60cf97d8b", "name": "Tanoodle", "location": "Pushchino", "currency": 71404 }, { "id": "c05cab25-3b26-4574-9757-486f73efc51c", "name": "Riffpath", "location": "Ban Lŭng", "currency": 74335 }, { "id": "bbb608f8-cbfe-434b-923b-8cafebacaeed", "name": "Oyondu", "location": "Września", "currency": 89295 }, { "id": "4a1d8f7a-5d57-48dc-80ca-22bfd7152a2d", "name": "Lajo", "location": "São Lourenço do Sul", "currency": 75566 }, { "id": "7251620d-3191-42d8-92b5-7dc66f49c74e", "name": "Oyoloo", "location": "Viedma", "currency": 4005 }, { "id": "a505b744-2b99-4234-81c3-df267c61386c", "name": "Oyoloo", "location": "Carmen", "currency": 86301 }, {
  "id": "707769f1-b94f-4e50-a51a-f05bc2e1575a",
  "name": "Trudeo",
  "location": "San Isidro de Lules",
  "currency": 86915
}, { "id": "a8aeb8e0-19c1-4bff-ad34-e8b69c0918e5", "name": "Podcat", "location": "Colón", "currency": 89647 }, { "id": "922996a4-3743-447d-9915-6a10546bbaf7", "name": "Jaxbean", "location": "Ängelholm", "currency": 15611 }, { "id": "c4ff18a8-bcd7-4896-9156-0010e56ad295", "name": "Tambee", "location": "Velikiye Luki", "currency": 6093 }, { "id": "8063f634-940a-4e94-8b65-8664ccfbb0aa", "name": "Babbleopia", "location": "Hayama", "currency": 43584 }, {
  "id": "0395a92e-647b-4764-9567-f46e6c33076f",
  "name": "Thoughtbeat",
  "location": "Guilherand-Granges",
  "currency": 88737
}, { "id": "ddfbc9c9-c967-42da-8c2d-ad722f125930", "name": "Eabox", "location": "Pathein", "currency": 39361 }, { "id": "49dbc422-3424-4474-8373-2c4cce063286", "name": "Oodoo", "location": "Las Vegas", "currency": 60993 }, { "id": "b2561449-ab39-4971-b746-bb1c2c3aa74e", "name": "Realbuzz", "location": "Kangasala", "currency": 49561 }, { "id": "71b83053-fa87-4ced-94dc-445e53ab44eb", "name": "Flashpoint", "location": "San Juan", "currency": 83544 }, { "id": "ecce0626-ed38-4a7a-b831-e2a6a7f39a9b", "name": "Youopia", "location": "Putrajaya", "currency": 18531 }, { "id": "1afe65c8-3d4b-4935-aea6-f87048f43fac", "name": "Katz", "location": "Salima", "currency": 67429 }, { "id": "7a88ffdc-fcef-4563-8286-1e690f656d85", "name": "Twimm", "location": "João Pessoa", "currency": 37667 }, { "id": "a0f7ec19-5aa6-4a40-8366-a6847de4edd3", "name": "Skaboo", "location": "Waterloo", "currency": 21244 }, { "id": "cc604a09-8443-446d-b778-9d59742889cf", "name": "Yakitri", "location": "Haikou", "currency": 96049 }, { "id": "3027f685-be1f-4e37-abec-d974d623f25c", "name": "Mymm", "location": "Mistřice", "currency": 54749 }, { "id": "4875768c-9d19-4603-b80f-eb400a6ac40f", "name": "Plambee", "location": "Sanxi", "currency": 63606 }, { "id": "cb46eda0-a9ac-4e6e-90f2-8f5c0bd1036e", "name": "Oloo", "location": "Jinji", "currency": 81809 }, { "id": "9f7d0473-5dcf-47fd-90a0-5ca2d848b2fa", "name": "Kwimbee", "location": "Saumur", "currency": 88833 }, { "id": "15fe622a-51be-4f4f-96f9-3bfe03fc8131", "name": "Realpoint", "location": "Ximafang", "currency": 17882 }, { "id": "68d0f1a3-e9bc-4bce-8530-be7c529a7877", "name": "Yodo", "location": "Taiping", "currency": 97922 }, { "id": "1ad711cd-a035-4913-b2a1-40f4921c791e", "name": "Twitterbeat", "location": "Raofeng", "currency": 36863 }, { "id": "123e5b7c-9e2a-4388-8ce3-65ea0b7e9ef4", "name": "Izio", "location": "Jiqu", "currency": 91370 }, { "id": "f81cf997-60d1-45a5-b27d-7868bf0081a1", "name": "Kayveo", "location": "El Bálsamo", "currency": 22073 }, { "id": "3b56dbe7-3837-443f-96dc-5da7adb1e62a", "name": "Skimia", "location": "Varakļāni", "currency": 9097 }, { "id": "cdc765e6-fb39-4f8c-b93c-8ed03eb38ca3", "name": "Avaveo", "location": "Lešná", "currency": 17400 }, { "id": "e5caade0-43fc-44d1-a527-0b3de1889258", "name": "Mydeo", "location": "Mir", "currency": 1180 }, { "id": "21fb6412-8bc3-4319-b8c5-f0fc07cd3fed", "name": "Linktype", "location": "Heyou", "currency": 81378 }, { "id": "532a5001-ce63-449d-9dcd-04ecc2ec6c0f", "name": "Topicshots", "location": "Chenggang", "currency": 11810 }, { "id": "0c10090e-65ad-4a03-ad75-5dbddd6f9fe6", "name": "Chatterpoint", "location": "Ljungby", "currency": 49076 }, { "id": "6b99fdd7-329c-4781-9f0c-2f8907eb465a", "name": "Jazzy", "location": "Nevers", "currency": 46754 }, { "id": "3cf9ee12-a390-4b28-9747-c7b45fdbdfe5", "name": "Pixope", "location": "Lapuz", "currency": 15500 }, { "id": "6a4c8296-ffae-4103-b6cd-8bcecacf2ac0", "name": "Bubblemix", "location": "Hukeng", "currency": 27912 }, { "id": "115d7319-af16-444e-bdc1-b2f51f29758d", "name": "Bubbletube", "location": "Khon Buri", "currency": 79784 }, { "id": "f95656db-4d04-4cfc-bcb8-c452464bfda1", "name": "Skiba", "location": "Massy", "currency": 28843 }, { "id": "8d6f80f0-8d9f-4c0a-973c-a7769e1a2188", "name": "Bluezoom", "location": "Campurrejo", "currency": 47192 }, { "id": "5879579d-a916-474d-93b6-ba9a591e566c", "name": "Digitube", "location": "Karlskoga", "currency": 62907 }, { "id": "85682356-e9d9-4461-bd2e-0b610f2f2fe4", "name": "Fanoodle", "location": "Daleman", "currency": 98093 }, { "id": "e21aa67e-b73d-4a59-9d4c-e90fdbeebed0", "name": "Ntags", "location": "Cárdenas", "currency": 47963 }, { "id": "0628f0ca-a0b9-4cfe-b6b7-fbd9c5a4edd1", "name": "Tagtune", "location": "Irkutsk", "currency": 5202 }, { "id": "7ac60c35-2416-4827-a56d-6b7d3116b85e", "name": "Bluejam", "location": "Tangub", "currency": 60158 }, { "id": "9bb7baea-9b82-414e-8c5a-26334b87e6e9", "name": "Izio", "location": "Липково", "currency": 14923 }, { "id": "1df4f503-92df-44db-a096-96d0dd51002a", "name": "Photospace", "location": "Huangjiakou", "currency": 75432 }, { "id": "0f08b310-7b78-4e55-b1e7-e56d02338aed", "name": "Quimm", "location": "‘Abs", "currency": 92707 }, { "id": "b2d322a4-49e7-43e9-bd88-486e3d96360f", "name": "Riffpedia", "location": "Xiazhai", "currency": 190 }, { "id": "c82db0c7-26d7-4082-b8b9-d8b56ceda707", "name": "Camimbo", "location": "Arteche", "currency": 66364 }, { "id": "01fc5176-5e5a-4531-aed5-929c5c629c0b", "name": "Jayo", "location": "Seidu", "currency": 32747 }, { "id": "14a49726-c13a-4152-ad26-c93754785b3d", "name": "Kayveo", "location": "Utrecht (stad)", "currency": 36925 }, { "id": "51143422-07c7-4701-bdfe-4e24425e909c", "name": "Realfire", "location": "Ribeirão Preto", "currency": 44539 }, { "id": "6059c1ab-4c12-4c9a-8720-9fabdb71f746", "name": "Twinder", "location": "Babice", "currency": 19430 }, { "id": "aa3661fc-cc01-401e-a1f2-0ad4dce8553b", "name": "Gabvine", "location": "Lecong", "currency": 74160 }, { "id": "060bcfad-fb5b-4da5-af84-a0035ad53e23", "name": "Npath", "location": "Otradnaya", "currency": 37173 }, { "id": "2c39a975-2c7e-483d-8427-8c5092f0e333", "name": "Oozz", "location": "Gandu", "currency": 59748 }, { "id": "a07d7392-1bf6-40a8-ac88-e2f3d708d5db", "name": "Tekfly", "location": "Coro", "currency": 47162 }, { "id": "35f340c0-3e0e-417c-8894-80557af16fe2", "name": "Kimia", "location": "Kuwayris Sharqī", "currency": 16606 }, { "id": "b4b150eb-4d5b-49b0-9ec3-3949855159ad", "name": "Buzzster", "location": "Hultsfred", "currency": 91024 }, { "id": "1cc5c1df-361f-4d17-b055-33c48841e52e", "name": "Zoomdog", "location": "Xingshou", "currency": 62876 }, { "id": "444ad534-21f5-4ffd-93c3-469e98b17c8e", "name": "Pixoboo", "location": "Krajan", "currency": 88233 }, { "id": "bba1ee7a-fbd0-4fd4-8d0f-bc140f00e62e", "name": "Ntags", "location": "Port Moody", "currency": 75055 }, { "id": "85e4e100-6afd-459f-a368-eb393f4647ef", "name": "Fivespan", "location": "Tyszowce", "currency": 92215 }, {
  "id": "20e97afe-524c-4158-8873-75eec0bfc500",
  "name": "Riffpath",
  "location": "Cangkeuteuk Sabrang",
  "currency": 21055
}, { "id": "a0462f60-5a2e-461c-8fcb-e6d9f609ebc8", "name": "Tanoodle", "location": "Psachná", "currency": 9873 }, { "id": "2875274b-b655-4684-aa09-0312c98d20e3", "name": "Geba", "location": "Seoam", "currency": 23754 }, { "id": "72d9776c-268b-4f15-a3a2-1e8ad6f10661", "name": "Janyx", "location": "Sanjiang", "currency": 9878 }, { "id": "56f7cb46-0e90-46e0-90f1-d1b4d261cd2f", "name": "Wikizz", "location": "Bojong", "currency": 33153 }, { "id": "d0e8718a-bc28-468e-b678-1d1621ca62ac", "name": "Rhynoodle", "location": "Castelo", "currency": 89884 }, { "id": "2859f879-65f0-4da6-8ddf-ed8ee39b5a5f", "name": "Realbuzz", "location": "Sakado", "currency": 23284 }, { "id": "12e13e1d-7576-4842-abbd-de18e0a8de90", "name": "Skipstorm", "location": "Vukojevci", "currency": 76407 }, { "id": "789b5163-7377-4cbb-b68c-67d4b94e0288", "name": "Cogidoo", "location": "Vrdy", "currency": 43982 }, { "id": "d13c435d-75c6-4459-87ac-dde74a1aa971", "name": "Jaxworks", "location": "Nanterre", "currency": 48381 }, { "id": "02c05195-cb53-49c8-9eed-227c4f2d53be", "name": "Skyble", "location": "Córdoba", "currency": 59443 }, { "id": "bfe89363-6509-41e4-ba35-6fe34c7cd144", "name": "Realpoint", "location": "Kirovsk", "currency": 33964 }, { "id": "97fe6609-6ecf-4101-bcb3-01e9273bea21", "name": "Wordware", "location": "Yefremov", "currency": 23670 }, { "id": "516c6227-2212-4f5f-8f55-084df3ccb883", "name": "Fivespan", "location": "Clorinda", "currency": 88717 }, { "id": "5451942e-4343-4eac-bc25-bacc7a913b2d", "name": "Voomm", "location": "Sumberejo", "currency": 17832 }, { "id": "73876277-20e5-4a60-81b4-bc7a2dca3f0a", "name": "Brightbean", "location": "Shangmachang", "currency": 37551 }, { "id": "1f969fbf-f345-4f3a-9205-94f87547f272", "name": "Edgeify", "location": "Itarana", "currency": 77756 }, { "id": "e32bac8d-6b1a-4868-b072-4b046721259c", "name": "Devpulse", "location": "Usagara", "currency": 45805 }, { "id": "03918375-e31a-4dda-a63a-52895433d91b", "name": "Photobean", "location": "Vrachnaíika", "currency": 27921 }, { "id": "82325564-a75c-4c53-b372-44002b4dcc1a", "name": "Abatz", "location": "Shakhty", "currency": 35748 }, { "id": "c447773e-3e06-46a6-82e6-e8bba126468b", "name": "Thoughtsphere", "location": "Hohoe", "currency": 28175 }, { "id": "3f477ee7-1483-4b10-9939-d652df5faaea", "name": "Quimba", "location": "Żurowa", "currency": 2134 }, { "id": "2fcf554d-41c4-41bd-b046-92050553cda8", "name": "Linkbridge", "location": "Nanortalik", "currency": 76342 }, { "id": "d6973825-a7bb-4d20-9edc-4713faca80b2", "name": "Realpoint", "location": "Waitun", "currency": 52433 }, { "id": "8cb2f9c2-ef58-45fd-b304-2e4af6e99989", "name": "Edgepulse", "location": "El Crucero", "currency": 4744 }, { "id": "04302a95-a920-41be-9c8d-6ab606d1262c", "name": "Trilia", "location": "Wujia", "currency": 8181 }, { "id": "9e78df38-dc75-4089-a85b-779a7ee65a35", "name": "Skyble", "location": "Don Tan", "currency": 93047 }, { "id": "bf88fa78-3b87-4be5-87a8-6f87981843ba", "name": "Shuffletag", "location": "Xiaoshanzi", "currency": 37129 }, { "id": "2ee3c7f6-ce50-4b7c-9694-4c5832ac7969", "name": "Realpoint", "location": "Ros’", "currency": 50306 }, { "id": "97b9f7b9-44a9-4512-839a-1825848e0761", "name": "Zooveo", "location": "Arraial do Cabo", "currency": 8635 }, { "id": "c222fa2f-bf6c-4cc9-b349-5cced18877b7", "name": "Innojam", "location": "Kvissleby", "currency": 33747 }, { "id": "dcb5d8ac-8ac9-4c66-84a6-9d4b6a3bf9af", "name": "Fivechat", "location": "Antou", "currency": 61418 }, {
  "id": "31637f7e-312a-4271-8cde-a06c95b47aaf",
  "name": "Brainsphere",
  "location": "Stuttgart Stuttgart-Mitte",
  "currency": 17466
}, { "id": "32c0a116-7829-48ba-9233-f56b210adacd", "name": "Skipstorm", "location": "Ojos de Agua", "currency": 90204 }, { "id": "cca961f6-e0c1-4bc8-8a1c-98263b84bebd", "name": "Zooveo", "location": "Vale", "currency": 27682 }, { "id": "72f501cc-3bed-43ab-bbf7-bf9280076412", "name": "Demivee", "location": "Zhouling", "currency": 10808 }, {
  "id": "cbbbc003-ad35-4b43-a342-6c11d5266385",
  "name": "Riffpath",
  "location": "Saint-Lambert-de-Lauzon",
  "currency": 34750
}, { "id": "c03ef79d-fe01-4d4d-b970-51125bf53626", "name": "Oyoba", "location": "Samaipata", "currency": 43218 }, { "id": "e2f277de-37d8-4a62-b991-6e45b8cf0da0", "name": "Eidel", "location": "Shangping", "currency": 55689 }, { "id": "5b7d1813-dbfe-4db2-8771-48da181a04fe", "name": "Bubbletube", "location": "Lurut", "currency": 61175 }, { "id": "77642b0b-e82c-4ba3-b294-c7274697ae9b", "name": "Kimia", "location": "Maracha", "currency": 90561 }, { "id": "cab97bf6-383f-401f-9441-0adb77db5302", "name": "Devbug", "location": "Karanggintung", "currency": 24572 }, { "id": "7e16e925-56a9-4dfe-b562-735c0115e55d", "name": "Buzzshare", "location": "Dongzhang", "currency": 53965 }, { "id": "878738f0-3380-495f-afb5-09850e6cf823", "name": "Trudeo", "location": "Motema", "currency": 73955 }, { "id": "15ff8702-1cde-47b9-b560-704c5df30fa0", "name": "Mynte", "location": "Znamenka", "currency": 8645 }, { "id": "da5e349a-0fa6-41d6-b5c0-87ad7c14c32d", "name": "Roodel", "location": "Tempaling", "currency": 35788 }, { "id": "0cf5a6e9-dbe9-4a34-8d86-e2132383351e", "name": "Skyndu", "location": "Ramotswa", "currency": 26501 }, { "id": "b656e71d-e695-497a-9ddd-c258cd13f519", "name": "Fivechat", "location": "Čapljina", "currency": 81287 }, { "id": "ebc007d3-9e7f-4faa-ae7c-69d8df08f7de", "name": "Shufflebeat", "location": "Hanting", "currency": 64861 }, { "id": "abac4d50-e93f-4913-9d40-e0a59ead76c8", "name": "Oyonder", "location": "Sewon", "currency": 58557 }, { "id": "73a1a935-9a46-4c23-9980-554aaa6abe26", "name": "Realfire", "location": "Marseille", "currency": 32861 }, { "id": "53ac0ca8-938c-4b1e-97b5-a76f90006ece", "name": "Roodel", "location": "Rukaj", "currency": 17681 }, { "id": "9ec48812-9691-4415-b90b-b4ff032d7557", "name": "Kwideo", "location": "Musina", "currency": 89104 }, { "id": "86f3abdd-bd2f-4a0c-b34e-bd73147d635c", "name": "Digitube", "location": "Bangunharja", "currency": 10191 }, { "id": "4f30f32c-2b62-43b7-89c5-fc956ff71400", "name": "Kwimbee", "location": "Detroit", "currency": 66307 }, { "id": "13b19d61-c193-4440-aff6-67a9103ea18d", "name": "Zoovu", "location": "Juanshui", "currency": 30588 }, { "id": "fe591b83-5ce8-4b8d-afca-6c47c0d1751e", "name": "Eare", "location": "Fomento", "currency": 54381 }, { "id": "d300bc0c-54b3-4fce-8be5-9b219ecc28b5", "name": "Dabshots", "location": "Benito Juarez", "currency": 66255 }, { "id": "624da253-64c7-418a-bc3a-8ca7401561c7", "name": "Dynava", "location": "Le Havre", "currency": 56025 }, { "id": "5721128e-3130-4f7b-a29c-77be9f511aec", "name": "Eare", "location": "Ratchathewi", "currency": 42388 }];

new _vue2.default({
  el: '#app',
  data: {
    list: [],
    sortedParams: {
      isSorted: false,
      reverse: false,
      name: null
    },
    filter: {
      param: null,
      filteredList: null
    },
    modals: {
      edit: {
        show: false,
        value: null,
        index: null,
        name: null
      }
    },
    test: false
  },
  created: function created() {
    var _this = this;

    return this.$http.get('/list').then(function (response) {
      _this.list = response.list;
    }).catch(function (err) {
      console.log(err);
      _this.list = window.list ? window.list : data;
    });
  },

  watch: {
    'filter.param': function filterParam(newValue) {
      if (newValue) {
        this.filter.filteredList = this.list.filter(function (item) {
          for (var key in item) {
            if (item[key].toString().toLowerCase().match(newValue)) {
              return item;
            }
          }
        });
      }
    }
  },
  computed: {
    listCurrencySumm: function listCurrencySumm() {
      return this.list.map(function (item) {
        return item.currency;
      }).reduce(function (prev, next) {
        return prev + next;
      }, 0);
    },
    sortedList: function sortedList() {
      if (this.filter.param) {
        return this.filter.filteredList;
      } else if (this.sortedParams.isSorted) {
        return this.list.sort(this.sorting(this.sortedParams.name, this.sortedParams.reverse));
      } else {
        return this.list;
      }
    }
  },
  methods: {
    editItem: function editItem(index, name) {
      this.modals.edit.index = index;
      this.modals.edit.name = name;
    },
    editItemConfirm: function editItemConfirm() {
      var _this2 = this;

      return this.$http.post('/item', {
        list_item_id: this.modals.edit.index
      }).then(function (res) {
        if (_this2.modals.edit.name === 'currency') {
          _this2.list[_this2.modals.edit.index][_this2.modals.edit.name] = parseInt(_this2.modals.edit.value ? _this2.modals.edit.value : 0);
        } else {
          _this2.list[_this2.modals.edit.index][_this2.modals.edit.name] = _this2.modals.edit.value;
        }
        _this2.modals.edit.value = null;
      }).catch(function (error) {
        console.error(error);
        /**
         * Это будет пока тут что работало без бека
         * */
        if (_this2.modals.edit.name === 'currency') {
          _this2.list[_this2.modals.edit.index][_this2.modals.edit.name] = parseInt(_this2.modals.edit.value ? _this2.modals.edit.value : 0);
        } else {
          _this2.list[_this2.modals.edit.index][_this2.modals.edit.name] = _this2.modals.edit.value;
        }
        _this2.modals.edit.value = null;
      });
    },
    sorting: function sorting(prop, reverse) {
      return function (a, b) {
        if (a[prop] < b[prop]) return reverse ? 1 : -1;
        if (a[prop] > b[prop]) return reverse ? -1 : 1;
        return 0;
      };
    },
    sortList: function sortList(param, reverse) {
      var _this3 = this;

      this.$nextTick(function () {
        _this3.sortedParams.isSorted = true;
        _this3.sortedParams.name = param;
        _this3.sortedParams.reverse = reverse;
      });
    }
  }
});

/***/ }),
/* 5 */,
/* 6 */,
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Url", function() { return Url; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Http", function() { return Http; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Resource", function() { return Resource; });
/*!
 * vue-resource v1.3.5
 * https://github.com/pagekit/vue-resource
 * Released under the MIT License.
 */

/**
 * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
 */

var RESOLVED = 0;
var REJECTED = 1;
var PENDING  = 2;

function Promise$1(executor) {

    this.state = PENDING;
    this.value = undefined;
    this.deferred = [];

    var promise = this;

    try {
        executor(function (x) {
            promise.resolve(x);
        }, function (r) {
            promise.reject(r);
        });
    } catch (e) {
        promise.reject(e);
    }
}

Promise$1.reject = function (r) {
    return new Promise$1(function (resolve, reject) {
        reject(r);
    });
};

Promise$1.resolve = function (x) {
    return new Promise$1(function (resolve, reject) {
        resolve(x);
    });
};

Promise$1.all = function all(iterable) {
    return new Promise$1(function (resolve, reject) {
        var count = 0, result = [];

        if (iterable.length === 0) {
            resolve(result);
        }

        function resolver(i) {
            return function (x) {
                result[i] = x;
                count += 1;

                if (count === iterable.length) {
                    resolve(result);
                }
            };
        }

        for (var i = 0; i < iterable.length; i += 1) {
            Promise$1.resolve(iterable[i]).then(resolver(i), reject);
        }
    });
};

Promise$1.race = function race(iterable) {
    return new Promise$1(function (resolve, reject) {
        for (var i = 0; i < iterable.length; i += 1) {
            Promise$1.resolve(iterable[i]).then(resolve, reject);
        }
    });
};

var p$1 = Promise$1.prototype;

p$1.resolve = function resolve(x) {
    var promise = this;

    if (promise.state === PENDING) {
        if (x === promise) {
            throw new TypeError('Promise settled with itself.');
        }

        var called = false;

        try {
            var then = x && x['then'];

            if (x !== null && typeof x === 'object' && typeof then === 'function') {
                then.call(x, function (x) {
                    if (!called) {
                        promise.resolve(x);
                    }
                    called = true;

                }, function (r) {
                    if (!called) {
                        promise.reject(r);
                    }
                    called = true;
                });
                return;
            }
        } catch (e) {
            if (!called) {
                promise.reject(e);
            }
            return;
        }

        promise.state = RESOLVED;
        promise.value = x;
        promise.notify();
    }
};

p$1.reject = function reject(reason) {
    var promise = this;

    if (promise.state === PENDING) {
        if (reason === promise) {
            throw new TypeError('Promise settled with itself.');
        }

        promise.state = REJECTED;
        promise.value = reason;
        promise.notify();
    }
};

p$1.notify = function notify() {
    var promise = this;

    nextTick(function () {
        if (promise.state !== PENDING) {
            while (promise.deferred.length) {
                var deferred = promise.deferred.shift(),
                    onResolved = deferred[0],
                    onRejected = deferred[1],
                    resolve = deferred[2],
                    reject = deferred[3];

                try {
                    if (promise.state === RESOLVED) {
                        if (typeof onResolved === 'function') {
                            resolve(onResolved.call(undefined, promise.value));
                        } else {
                            resolve(promise.value);
                        }
                    } else if (promise.state === REJECTED) {
                        if (typeof onRejected === 'function') {
                            resolve(onRejected.call(undefined, promise.value));
                        } else {
                            reject(promise.value);
                        }
                    }
                } catch (e) {
                    reject(e);
                }
            }
        }
    });
};

p$1.then = function then(onResolved, onRejected) {
    var promise = this;

    return new Promise$1(function (resolve, reject) {
        promise.deferred.push([onResolved, onRejected, resolve, reject]);
        promise.notify();
    });
};

p$1.catch = function (onRejected) {
    return this.then(undefined, onRejected);
};

/**
 * Promise adapter.
 */

if (typeof Promise === 'undefined') {
    window.Promise = Promise$1;
}

function PromiseObj(executor, context) {

    if (executor instanceof Promise) {
        this.promise = executor;
    } else {
        this.promise = new Promise(executor.bind(context));
    }

    this.context = context;
}

PromiseObj.all = function (iterable, context) {
    return new PromiseObj(Promise.all(iterable), context);
};

PromiseObj.resolve = function (value, context) {
    return new PromiseObj(Promise.resolve(value), context);
};

PromiseObj.reject = function (reason, context) {
    return new PromiseObj(Promise.reject(reason), context);
};

PromiseObj.race = function (iterable, context) {
    return new PromiseObj(Promise.race(iterable), context);
};

var p = PromiseObj.prototype;

p.bind = function (context) {
    this.context = context;
    return this;
};

p.then = function (fulfilled, rejected) {

    if (fulfilled && fulfilled.bind && this.context) {
        fulfilled = fulfilled.bind(this.context);
    }

    if (rejected && rejected.bind && this.context) {
        rejected = rejected.bind(this.context);
    }

    return new PromiseObj(this.promise.then(fulfilled, rejected), this.context);
};

p.catch = function (rejected) {

    if (rejected && rejected.bind && this.context) {
        rejected = rejected.bind(this.context);
    }

    return new PromiseObj(this.promise.catch(rejected), this.context);
};

p.finally = function (callback) {

    return this.then(function (value) {
            callback.call(this);
            return value;
        }, function (reason) {
            callback.call(this);
            return Promise.reject(reason);
        }
    );
};

/**
 * Utility functions.
 */

var ref = {};
var hasOwnProperty = ref.hasOwnProperty;

var ref$1 = [];
var slice = ref$1.slice;
var debug = false;
var ntick;

var inBrowser = typeof window !== 'undefined';

function Util (ref) {
    var config = ref.config;
    var nextTick = ref.nextTick;

    ntick = nextTick;
    debug = config.debug || !config.silent;
}

function warn(msg) {
    if (typeof console !== 'undefined' && debug) {
        console.warn('[VueResource warn]: ' + msg);
    }
}

function error(msg) {
    if (typeof console !== 'undefined') {
        console.error(msg);
    }
}

function nextTick(cb, ctx) {
    return ntick(cb, ctx);
}

function trim(str) {
    return str ? str.replace(/^\s*|\s*$/g, '') : '';
}

function trimEnd(str, chars) {

    if (str && chars === undefined) {
        return str.replace(/\s+$/, '');
    }

    if (!str || !chars) {
        return str;
    }

    return str.replace(new RegExp(("[" + chars + "]+$")), '');
}

function toLower(str) {
    return str ? str.toLowerCase() : '';
}

function toUpper(str) {
    return str ? str.toUpperCase() : '';
}

var isArray = Array.isArray;

function isString(val) {
    return typeof val === 'string';
}



function isFunction(val) {
    return typeof val === 'function';
}

function isObject(obj) {
    return obj !== null && typeof obj === 'object';
}

function isPlainObject(obj) {
    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;
}

function isBlob(obj) {
    return typeof Blob !== 'undefined' && obj instanceof Blob;
}

function isFormData(obj) {
    return typeof FormData !== 'undefined' && obj instanceof FormData;
}

function when(value, fulfilled, rejected) {

    var promise = PromiseObj.resolve(value);

    if (arguments.length < 2) {
        return promise;
    }

    return promise.then(fulfilled, rejected);
}

function options(fn, obj, opts) {

    opts = opts || {};

    if (isFunction(opts)) {
        opts = opts.call(obj);
    }

    return merge(fn.bind({$vm: obj, $options: opts}), fn, {$options: opts});
}

function each(obj, iterator) {

    var i, key;

    if (isArray(obj)) {
        for (i = 0; i < obj.length; i++) {
            iterator.call(obj[i], obj[i], i);
        }
    } else if (isObject(obj)) {
        for (key in obj) {
            if (hasOwnProperty.call(obj, key)) {
                iterator.call(obj[key], obj[key], key);
            }
        }
    }

    return obj;
}

var assign = Object.assign || _assign;

function merge(target) {

    var args = slice.call(arguments, 1);

    args.forEach(function (source) {
        _merge(target, source, true);
    });

    return target;
}

function defaults(target) {

    var args = slice.call(arguments, 1);

    args.forEach(function (source) {

        for (var key in source) {
            if (target[key] === undefined) {
                target[key] = source[key];
            }
        }

    });

    return target;
}

function _assign(target) {

    var args = slice.call(arguments, 1);

    args.forEach(function (source) {
        _merge(target, source);
    });

    return target;
}

function _merge(target, source, deep) {
    for (var key in source) {
        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
                target[key] = {};
            }
            if (isArray(source[key]) && !isArray(target[key])) {
                target[key] = [];
            }
            _merge(target[key], source[key], deep);
        } else if (source[key] !== undefined) {
            target[key] = source[key];
        }
    }
}

/**
 * Root Prefix Transform.
 */

function root (options$$1, next) {

    var url = next(options$$1);

    if (isString(options$$1.root) && !/^(https?:)?\//.test(url)) {
        url = trimEnd(options$$1.root, '/') + '/' + url;
    }

    return url;
}

/**
 * Query Parameter Transform.
 */

function query (options$$1, next) {

    var urlParams = Object.keys(Url.options.params), query = {}, url = next(options$$1);

    each(options$$1.params, function (value, key) {
        if (urlParams.indexOf(key) === -1) {
            query[key] = value;
        }
    });

    query = Url.params(query);

    if (query) {
        url += (url.indexOf('?') == -1 ? '?' : '&') + query;
    }

    return url;
}

/**
 * URL Template v2.0.6 (https://github.com/bramstein/url-template)
 */

function expand(url, params, variables) {

    var tmpl = parse(url), expanded = tmpl.expand(params);

    if (variables) {
        variables.push.apply(variables, tmpl.vars);
    }

    return expanded;
}

function parse(template) {

    var operators = ['+', '#', '.', '/', ';', '?', '&'], variables = [];

    return {
        vars: variables,
        expand: function expand(context) {
            return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
                if (expression) {

                    var operator = null, values = [];

                    if (operators.indexOf(expression.charAt(0)) !== -1) {
                        operator = expression.charAt(0);
                        expression = expression.substr(1);
                    }

                    expression.split(/,/g).forEach(function (variable) {
                        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
                        variables.push(tmp[1]);
                    });

                    if (operator && operator !== '+') {

                        var separator = ',';

                        if (operator === '?') {
                            separator = '&';
                        } else if (operator !== '#') {
                            separator = operator;
                        }

                        return (values.length !== 0 ? operator : '') + values.join(separator);
                    } else {
                        return values.join(',');
                    }

                } else {
                    return encodeReserved(literal);
                }
            });
        }
    };
}

function getValues(context, operator, key, modifier) {

    var value = context[key], result = [];

    if (isDefined(value) && value !== '') {
        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
            value = value.toString();

            if (modifier && modifier !== '*') {
                value = value.substring(0, parseInt(modifier, 10));
            }

            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
        } else {
            if (modifier === '*') {
                if (Array.isArray(value)) {
                    value.filter(isDefined).forEach(function (value) {
                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
                    });
                } else {
                    Object.keys(value).forEach(function (k) {
                        if (isDefined(value[k])) {
                            result.push(encodeValue(operator, value[k], k));
                        }
                    });
                }
            } else {
                var tmp = [];

                if (Array.isArray(value)) {
                    value.filter(isDefined).forEach(function (value) {
                        tmp.push(encodeValue(operator, value));
                    });
                } else {
                    Object.keys(value).forEach(function (k) {
                        if (isDefined(value[k])) {
                            tmp.push(encodeURIComponent(k));
                            tmp.push(encodeValue(operator, value[k].toString()));
                        }
                    });
                }

                if (isKeyOperator(operator)) {
                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));
                } else if (tmp.length !== 0) {
                    result.push(tmp.join(','));
                }
            }
        }
    } else {
        if (operator === ';') {
            result.push(encodeURIComponent(key));
        } else if (value === '' && (operator === '&' || operator === '?')) {
            result.push(encodeURIComponent(key) + '=');
        } else if (value === '') {
            result.push('');
        }
    }

    return result;
}

function isDefined(value) {
    return value !== undefined && value !== null;
}

function isKeyOperator(operator) {
    return operator === ';' || operator === '&' || operator === '?';
}

function encodeValue(operator, value, key) {

    value = (operator === '+' || operator === '#') ? encodeReserved(value) : encodeURIComponent(value);

    if (key) {
        return encodeURIComponent(key) + '=' + value;
    } else {
        return value;
    }
}

function encodeReserved(str) {
    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
        if (!/%[0-9A-Fa-f]/.test(part)) {
            part = encodeURI(part);
        }
        return part;
    }).join('');
}

/**
 * URL Template (RFC 6570) Transform.
 */

function template (options) {

    var variables = [], url = expand(options.url, options.params, variables);

    variables.forEach(function (key) {
        delete options.params[key];
    });

    return url;
}

/**
 * Service for URL templating.
 */

function Url(url, params) {

    var self = this || {}, options$$1 = url, transform;

    if (isString(url)) {
        options$$1 = {url: url, params: params};
    }

    options$$1 = merge({}, Url.options, self.$options, options$$1);

    Url.transforms.forEach(function (handler) {

        if (isString(handler)) {
            handler = Url.transform[handler];
        }

        if (isFunction(handler)) {
            transform = factory(handler, transform, self.$vm);
        }

    });

    return transform(options$$1);
}

/**
 * Url options.
 */

Url.options = {
    url: '',
    root: null,
    params: {}
};

/**
 * Url transforms.
 */

Url.transform = {template: template, query: query, root: root};
Url.transforms = ['template', 'query', 'root'];

/**
 * Encodes a Url parameter string.
 *
 * @param {Object} obj
 */

Url.params = function (obj) {

    var params = [], escape = encodeURIComponent;

    params.add = function (key, value) {

        if (isFunction(value)) {
            value = value();
        }

        if (value === null) {
            value = '';
        }

        this.push(escape(key) + '=' + escape(value));
    };

    serialize(params, obj);

    return params.join('&').replace(/%20/g, '+');
};

/**
 * Parse a URL and return its components.
 *
 * @param {String} url
 */

Url.parse = function (url) {

    var el = document.createElement('a');

    if (document.documentMode) {
        el.href = url;
        url = el.href;
    }

    el.href = url;

    return {
        href: el.href,
        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',
        port: el.port,
        host: el.host,
        hostname: el.hostname,
        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,
        search: el.search ? el.search.replace(/^\?/, '') : '',
        hash: el.hash ? el.hash.replace(/^#/, '') : ''
    };
};

function factory(handler, next, vm) {
    return function (options$$1) {
        return handler.call(vm, options$$1, next);
    };
}

function serialize(params, obj, scope) {

    var array = isArray(obj), plain = isPlainObject(obj), hash;

    each(obj, function (value, key) {

        hash = isObject(value) || isArray(value);

        if (scope) {
            key = scope + '[' + (plain || hash ? key : '') + ']';
        }

        if (!scope && array) {
            params.add(value.name, value.value);
        } else if (hash) {
            serialize(params, value, key);
        } else {
            params.add(key, value);
        }
    });
}

/**
 * XDomain client (Internet Explorer).
 */

function xdrClient (request) {
    return new PromiseObj(function (resolve) {

        var xdr = new XDomainRequest(), handler = function (ref) {
            var type = ref.type;


            var status = 0;

            if (type === 'load') {
                status = 200;
            } else if (type === 'error') {
                status = 500;
            }

            resolve(request.respondWith(xdr.responseText, {status: status}));
        };

        request.abort = function () { return xdr.abort(); };

        xdr.open(request.method, request.getUrl());

        if (request.timeout) {
            xdr.timeout = request.timeout;
        }

        xdr.onload = handler;
        xdr.onabort = handler;
        xdr.onerror = handler;
        xdr.ontimeout = handler;
        xdr.onprogress = function () {};
        xdr.send(request.getBody());
    });
}

/**
 * CORS Interceptor.
 */

var SUPPORTS_CORS = inBrowser && 'withCredentials' in new XMLHttpRequest();

function cors (request, next) {

    if (inBrowser) {

        var orgUrl = Url.parse(location.href);
        var reqUrl = Url.parse(request.getUrl());

        if (reqUrl.protocol !== orgUrl.protocol || reqUrl.host !== orgUrl.host) {

            request.crossOrigin = true;
            request.emulateHTTP = false;

            if (!SUPPORTS_CORS) {
                request.client = xdrClient;
            }
        }
    }

    next();
}

/**
 * Form data Interceptor.
 */

function form (request, next) {

    if (isFormData(request.body)) {

        request.headers.delete('Content-Type');

    } else if (isObject(request.body) && request.emulateJSON) {

        request.body = Url.params(request.body);
        request.headers.set('Content-Type', 'application/x-www-form-urlencoded');
    }

    next();
}

/**
 * JSON Interceptor.
 */

function json (request, next) {

    var type = request.headers.get('Content-Type') || '';

    if (isObject(request.body) && type.indexOf('application/json') === 0) {
        request.body = JSON.stringify(request.body);
    }

    next(function (response) {

        return response.bodyText ? when(response.text(), function (text) {

            type = response.headers.get('Content-Type') || '';

            if (type.indexOf('application/json') === 0 || isJson(text)) {

                try {
                    response.body = JSON.parse(text);
                } catch (e) {
                    response.body = null;
                }

            } else {
                response.body = text;
            }

            return response;

        }) : response;

    });
}

function isJson(str) {

    var start = str.match(/^\s*(\[|\{)/);
    var end = {'[': /]\s*$/, '{': /}\s*$/};

    return start && end[start[1]].test(str);
}

/**
 * JSONP client (Browser).
 */

function jsonpClient (request) {
    return new PromiseObj(function (resolve) {

        var name = request.jsonp || 'callback', callback = request.jsonpCallback || '_jsonp' + Math.random().toString(36).substr(2), body = null, handler, script;

        handler = function (ref) {
            var type = ref.type;


            var status = 0;

            if (type === 'load' && body !== null) {
                status = 200;
            } else if (type === 'error') {
                status = 500;
            }

            if (status && window[callback]) {
                delete window[callback];
                document.body.removeChild(script);
            }

            resolve(request.respondWith(body, {status: status}));
        };

        window[callback] = function (result) {
            body = JSON.stringify(result);
        };

        request.abort = function () {
            handler({type: 'abort'});
        };

        request.params[name] = callback;

        if (request.timeout) {
            setTimeout(request.abort, request.timeout);
        }

        script = document.createElement('script');
        script.src = request.getUrl();
        script.type = 'text/javascript';
        script.async = true;
        script.onload = handler;
        script.onerror = handler;

        document.body.appendChild(script);
    });
}

/**
 * JSONP Interceptor.
 */

function jsonp (request, next) {

    if (request.method == 'JSONP') {
        request.client = jsonpClient;
    }

    next();
}

/**
 * Before Interceptor.
 */

function before (request, next) {

    if (isFunction(request.before)) {
        request.before.call(this, request);
    }

    next();
}

/**
 * HTTP method override Interceptor.
 */

function method (request, next) {

    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {
        request.headers.set('X-HTTP-Method-Override', request.method);
        request.method = 'POST';
    }

    next();
}

/**
 * Header Interceptor.
 */

function header (request, next) {

    var headers = assign({}, Http.headers.common,
        !request.crossOrigin ? Http.headers.custom : {},
        Http.headers[toLower(request.method)]
    );

    each(headers, function (value, name) {
        if (!request.headers.has(name)) {
            request.headers.set(name, value);
        }
    });

    next();
}

/**
 * XMLHttp client (Browser).
 */

function xhrClient (request) {
    return new PromiseObj(function (resolve) {

        var xhr = new XMLHttpRequest(), handler = function (event) {

            var response = request.respondWith(
                'response' in xhr ? xhr.response : xhr.responseText, {
                    status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug
                    statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText)
                }
            );

            each(trim(xhr.getAllResponseHeaders()).split('\n'), function (row) {
                response.headers.append(row.slice(0, row.indexOf(':')), row.slice(row.indexOf(':') + 1));
            });

            resolve(response);
        };

        request.abort = function () { return xhr.abort(); };

        if (request.progress) {
            if (request.method === 'GET') {
                xhr.addEventListener('progress', request.progress);
            } else if (/^(POST|PUT)$/i.test(request.method)) {
                xhr.upload.addEventListener('progress', request.progress);
            }
        }

        xhr.open(request.method, request.getUrl(), true);

        if (request.timeout) {
            xhr.timeout = request.timeout;
        }

        if (request.responseType && 'responseType' in xhr) {
            xhr.responseType = request.responseType;
        }

        if (request.withCredentials || request.credentials) {
            xhr.withCredentials = true;
        }

        if (!request.crossOrigin) {
            request.headers.set('X-Requested-With', 'XMLHttpRequest');
        }

        request.headers.forEach(function (value, name) {
            xhr.setRequestHeader(name, value);
        });

        xhr.onload = handler;
        xhr.onabort = handler;
        xhr.onerror = handler;
        xhr.ontimeout = handler;
        xhr.send(request.getBody());
    });
}

/**
 * Http client (Node).
 */

function nodeClient (request) {

    var client = __webpack_require__(8);

    return new PromiseObj(function (resolve) {

        var url = request.getUrl();
        var body = request.getBody();
        var method = request.method;
        var headers = {}, handler;

        request.headers.forEach(function (value, name) {
            headers[name] = value;
        });

        client(url, {body: body, method: method, headers: headers}).then(handler = function (resp) {

            var response = request.respondWith(resp.body, {
                    status: resp.statusCode,
                    statusText: trim(resp.statusMessage)
                }
            );

            each(resp.headers, function (value, name) {
                response.headers.set(name, value);
            });

            resolve(response);

        }, function (error$$1) { return handler(error$$1.response); });
    });
}

/**
 * Base client.
 */

function Client (context) {

    var reqHandlers = [sendRequest], resHandlers = [], handler;

    if (!isObject(context)) {
        context = null;
    }

    function Client(request) {
        return new PromiseObj(function (resolve, reject) {

            function exec() {

                handler = reqHandlers.pop();

                if (isFunction(handler)) {
                    handler.call(context, request, next);
                } else {
                    warn(("Invalid interceptor of type " + (typeof handler) + ", must be a function"));
                    next();
                }
            }

            function next(response) {

                if (isFunction(response)) {

                    resHandlers.unshift(response);

                } else if (isObject(response)) {

                    resHandlers.forEach(function (handler) {
                        response = when(response, function (response) {
                            return handler.call(context, response) || response;
                        }, reject);
                    });

                    when(response, resolve, reject);

                    return;
                }

                exec();
            }

            exec();

        }, context);
    }

    Client.use = function (handler) {
        reqHandlers.push(handler);
    };

    return Client;
}

function sendRequest(request, resolve) {

    var client = request.client || (inBrowser ? xhrClient : nodeClient);

    resolve(client(request));
}

/**
 * HTTP Headers.
 */

var Headers = function Headers(headers) {
    var this$1 = this;


    this.map = {};

    each(headers, function (value, name) { return this$1.append(name, value); });
};

Headers.prototype.has = function has (name) {
    return getName(this.map, name) !== null;
};

Headers.prototype.get = function get (name) {

    var list = this.map[getName(this.map, name)];

    return list ? list.join() : null;
};

Headers.prototype.getAll = function getAll (name) {
    return this.map[getName(this.map, name)] || [];
};

Headers.prototype.set = function set (name, value) {
    this.map[normalizeName(getName(this.map, name) || name)] = [trim(value)];
};

Headers.prototype.append = function append (name, value){

    var list = this.map[getName(this.map, name)];

    if (list) {
        list.push(trim(value));
    } else {
        this.set(name, value);
    }
};

Headers.prototype.delete = function delete$1 (name){
    delete this.map[getName(this.map, name)];
};

Headers.prototype.deleteAll = function deleteAll (){
    this.map = {};
};

Headers.prototype.forEach = function forEach (callback, thisArg) {
        var this$1 = this;

    each(this.map, function (list, name) {
        each(list, function (value) { return callback.call(thisArg, value, name, this$1); });
    });
};

function getName(map, name) {
    return Object.keys(map).reduce(function (prev, curr) {
        return toLower(name) === toLower(curr) ? curr : prev;
    }, null);
}

function normalizeName(name) {

    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
        throw new TypeError('Invalid character in header field name');
    }

    return trim(name);
}

/**
 * HTTP Response.
 */

var Response = function Response(body, ref) {
    var url = ref.url;
    var headers = ref.headers;
    var status = ref.status;
    var statusText = ref.statusText;


    this.url = url;
    this.ok = status >= 200 && status < 300;
    this.status = status || 0;
    this.statusText = statusText || '';
    this.headers = new Headers(headers);
    this.body = body;

    if (isString(body)) {

        this.bodyText = body;

    } else if (isBlob(body)) {

        this.bodyBlob = body;

        if (isBlobText(body)) {
            this.bodyText = blobText(body);
        }
    }
};

Response.prototype.blob = function blob () {
    return when(this.bodyBlob);
};

Response.prototype.text = function text () {
    return when(this.bodyText);
};

Response.prototype.json = function json () {
    return when(this.text(), function (text) { return JSON.parse(text); });
};

Object.defineProperty(Response.prototype, 'data', {

    get: function get() {
        return this.body;
    },

    set: function set(body) {
        this.body = body;
    }

});

function blobText(body) {
    return new PromiseObj(function (resolve) {

        var reader = new FileReader();

        reader.readAsText(body);
        reader.onload = function () {
            resolve(reader.result);
        };

    });
}

function isBlobText(body) {
    return body.type.indexOf('text') === 0 || body.type.indexOf('json') !== -1;
}

/**
 * HTTP Request.
 */

var Request = function Request(options$$1) {

    this.body = null;
    this.params = {};

    assign(this, options$$1, {
        method: toUpper(options$$1.method || 'GET')
    });

    if (!(this.headers instanceof Headers)) {
        this.headers = new Headers(this.headers);
    }
};

Request.prototype.getUrl = function getUrl (){
    return Url(this);
};

Request.prototype.getBody = function getBody (){
    return this.body;
};

Request.prototype.respondWith = function respondWith (body, options$$1) {
    return new Response(body, assign(options$$1 || {}, {url: this.getUrl()}));
};

/**
 * Service for sending network requests.
 */

var COMMON_HEADERS = {'Accept': 'application/json, text/plain, */*'};
var JSON_CONTENT_TYPE = {'Content-Type': 'application/json;charset=utf-8'};

function Http(options$$1) {

    var self = this || {}, client = Client(self.$vm);

    defaults(options$$1 || {}, self.$options, Http.options);

    Http.interceptors.forEach(function (handler) {

        if (isString(handler)) {
            handler = Http.interceptor[handler];
        }

        if (isFunction(handler)) {
            client.use(handler);
        }

    });

    return client(new Request(options$$1)).then(function (response) {

        return response.ok ? response : PromiseObj.reject(response);

    }, function (response) {

        if (response instanceof Error) {
            error(response);
        }

        return PromiseObj.reject(response);
    });
}

Http.options = {};

Http.headers = {
    put: JSON_CONTENT_TYPE,
    post: JSON_CONTENT_TYPE,
    patch: JSON_CONTENT_TYPE,
    delete: JSON_CONTENT_TYPE,
    common: COMMON_HEADERS,
    custom: {}
};

Http.interceptor = {before: before, method: method, jsonp: jsonp, json: json, form: form, header: header, cors: cors};
Http.interceptors = ['before', 'method', 'jsonp', 'json', 'form', 'header', 'cors'];

['get', 'delete', 'head', 'jsonp'].forEach(function (method$$1) {

    Http[method$$1] = function (url, options$$1) {
        return this(assign(options$$1 || {}, {url: url, method: method$$1}));
    };

});

['post', 'put', 'patch'].forEach(function (method$$1) {

    Http[method$$1] = function (url, body, options$$1) {
        return this(assign(options$$1 || {}, {url: url, method: method$$1, body: body}));
    };

});

/**
 * Service for interacting with RESTful services.
 */

function Resource(url, params, actions, options$$1) {

    var self = this || {}, resource = {};

    actions = assign({},
        Resource.actions,
        actions
    );

    each(actions, function (action, name) {

        action = merge({url: url, params: assign({}, params)}, options$$1, action);

        resource[name] = function () {
            return (self.$http || Http)(opts(action, arguments));
        };
    });

    return resource;
}

function opts(action, args) {

    var options$$1 = assign({}, action), params = {}, body;

    switch (args.length) {

        case 2:

            params = args[0];
            body = args[1];

            break;

        case 1:

            if (/^(POST|PUT|PATCH)$/i.test(options$$1.method)) {
                body = args[0];
            } else {
                params = args[0];
            }

            break;

        case 0:

            break;

        default:

            throw 'Expected up to 2 arguments [params, body], got ' + args.length + ' arguments';
    }

    options$$1.body = body;
    options$$1.params = assign({}, options$$1.params, params);

    return options$$1;
}

Resource.actions = {

    get: {method: 'GET'},
    save: {method: 'POST'},
    query: {method: 'GET'},
    update: {method: 'PUT'},
    remove: {method: 'DELETE'},
    delete: {method: 'DELETE'}

};

/**
 * Install plugin.
 */

function plugin(Vue) {

    if (plugin.installed) {
        return;
    }

    Util(Vue);

    Vue.url = Url;
    Vue.http = Http;
    Vue.resource = Resource;
    Vue.Promise = PromiseObj;

    Object.defineProperties(Vue.prototype, {

        $url: {
            get: function get() {
                return options(Vue.url, this, this.$options.url);
            }
        },

        $http: {
            get: function get() {
                return options(Vue.http, this, this.$options.http);
            }
        },

        $resource: {
            get: function get() {
                return Vue.resource.bind(this);
            }
        },

        $promise: {
            get: function get() {
                var this$1 = this;

                return function (executor) { return new Vue.Promise(executor, this$1); };
            }
        }

    });
}

if (typeof window !== 'undefined' && window.Vue) {
    window.Vue.use(plugin);
}

/* harmony default export */ __webpack_exports__["default"] = (plugin);



/***/ }),
/* 8 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(10);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(12)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {
	module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!./app.scss", function() {
		var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!./app.scss");

		if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(11)(false);
// imports


// module
exports.push([module.i, "/*---FLEXBOX MODEL PREFIX---*/\n.btn__mdi {\n  background: none;\n  border: none;\n  font-size: 16px;\n  line-height: 16px; }\n  .btn__mdi:hover {\n    color: green; }\n", ""]);

// exports


/***/ }),
/* 11 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target) {
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(13);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 13 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ })
],[3]);